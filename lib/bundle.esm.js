let e,t=[];function r(r,n={}){const s=()=>{o(s),e=s,t.push(e);const n=r();return t.pop(),e=t.at(-1),n};return s.options=n,s.deps=[],n.lazy||s(),s}const o=e=>{for(let t=0;t<e.deps.length;t++){e.deps[t].delete(e)}e.deps.length=0},n={};["includes","indexOf","lastIndexOf"].forEach((e=>{const t=Array.prototype[e];n[e]=function(...e){let r=t.apply(this,e);return r||(r=t.apply(this.raw,e)),r}}));let s=!1;const c={};["push","pop","shift","unshift","splice"].forEach((e=>{const t=Array.prototype[e];c[e]=function(...e){s=!0;const r=t.apply(this,e);return s=!1,r}}));let l=new WeakMap,a=Symbol();const u="ADD",f="SET",p="DEL",i="length",y=(e=!1,t=!1)=>({get(r,o,s){if(console.log("get:",o),"raw"===o)return r;if(Array.isArray(r)&&n.hasOwnProperty(o))return Reflect.get(n,o,s);if(Array.isArray(r)&&c.hasOwnProperty(o))return Reflect.get(c,o,s);t||"symbol"==typeof o||g(r,o);const l=Reflect.get(r,o,s);return e?l:"object"==typeof l&&null!==l?t?O(l):A(l):l},set(e,r,o,n){if(console.log("set:",r),t)return console.warn("当前为只读对象，不可编辑！"),!1;const s=e[r],c=Array.isArray(e)?Number(r)>e[i]-1?u:f:Object.prototype.hasOwnProperty.call(e,r)?f:u,l=Reflect.set(e,r,o,n);return e===n.raw&&(s===o||s!=s&&o!=o||h(e,r,c,o)),l},has:(e,t)=>(g(e,t),Reflect.has(e,t)),deleteProperty(e,r){if(t)return console.warn("当前为只读对象，不可删除！"),!1;const o=Object.prototype.hasOwnProperty.call(e,r),n=Reflect.deleteProperty(e,r);return o&&n&&h(e,r,p),n},ownKeys(e){const t=Array.isArray(e)?i:a;return g(e,t),Reflect.ownKeys(e)}}),g=(t,r)=>{if(!e||s)return t[r];let o=l.get(t);o||l.set(t,o=new Map);let n=o.get(r);n||o.set(r,n=new Set),n.add(e),e.deps.push(n)},h=(t,r,o,n)=>{console.log("type",o);const s=l.get(t);if(!s)return;const c=s.get(r),f=new Set,y=t=>{t&&t.forEach((t=>{t!==e&&f.add(t)}))};if(y(c),o===u||o===p){const e=s.get(a);y(e)}if(o===u&&Array.isArray(t)){console.log("01");const e=s.get(i);y(e)}Array.isArray(t)&&r===i&&(console.log("02"),s.forEach(((e,t)=>{t>=n&&y(e)}))),f.forEach((e=>{e.options.scheduler?e.options.scheduler(e):e()}))};function d(e,t=!1,r=!1){return new Proxy(e,y(t,r))}let w=new Map;function A(e){const t=w.get(e);if(t)return t;const r=d(e);return w.set(e,r),r}function R(e){return d(e,!0)}function O(e){return d(e,!1,!0)}function _(e){return d(e,!0,!0)}const b=e=>{const t={value:e};return Object.defineProperty(t,"__v_isRef",{value:!0}),A(t)},v=(e,t)=>{const r={get value(){return e[t]},set value(r){e[t]=r}};return Object.defineProperty(r,"__v_isRef",{value:!0}),console.log("wrapper",r),r},P=e=>{let t={};return Object.keys(e).forEach((r=>{t[r]=v(e,r)})),t},E=e=>new Proxy(e,{get(e,t,r){const o=Reflect.get(e,t,r);return o.__v_isRef?o.value:o},set(e,t,r,o){const n=e[t];return n.__v_isRef?(n.value=r,!0):Reflect.set(e,t,r,o)}});let j=A({foo:1,bar:2});const x=E({...P(j)});r((()=>{console.log("nObj",x.foo)})),j.foo=2,x.foo=3;export{r as effect,E as proxyRef,A as reactive,O as readOnly,b as ref,R as shallowReactive,_ as shallowReadOnly,v as toRef,P as toRefs};
